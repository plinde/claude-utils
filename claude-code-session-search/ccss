#!/usr/bin/env bash
#
# ccss - Claude Code Session Search
#
# Browse and search recent Claude Code sessions from ~/.claude/projects
#
# Usage: ccss [options] [count]
#   -n COUNT      Number of sessions to show
#   -a, --all     Include agent/subagent sessions
#   -s, --short   Use shortened paths (gh:, ws:, ~/)
#   -v, --verbose Show extra info (refs, file path, message count)
#   -g, --grep    Search sessions for keyword (case-sensitive)
#   -i            Case-insensitive search (use with -g)
#   -j, --json    Output as JSON
#   --from DATE   Only show sessions on or after DATE
#   --to DATE     Only show sessions on or before DATE
#   --by-start    Filter date range by session start time
#   --by-last     Filter date range by last activity (default)
#   --here        Only show sessions for current directory
#   -h, --help    Show help
#

# Configuration
PROJECTS_DIR="${HOME}/.claude/projects"
DEFAULT_COUNT=3

# Colors
C_CYAN='\033[36m'
C_YELLOW='\033[33m'
C_GRAY='\033[90m'
C_MAGENTA='\033[35m'
C_GREEN='\033[92m'
C_BLUE='\033[94m'
C_ORANGE='\033[93m'
C_RESET='\033[0m'

# Helper: Extract last user prompt from a session file
get_last_prompt() {
    local filepath="$1"
    grep '"type":"user"' "$filepath" 2>/dev/null | \
        jq -r 'select(.message.content | type == "string") | .message.content' 2>/dev/null | \
        grep -v '^\[Request' | \
        tail -1 | \
        tr '\n' ' ' | \
        sed 's/  */ /g' | \
        head -c 80
}

# Helper: Extract references from a session file
get_refs() {
    local filepath="$1"
    local urls jira branches

    # HTTP URLs - filter out noise and fragments
    urls=$(grep -oE 'https?://[^"<>\\[:space:]]{10,}' "$filepath" 2>/dev/null | \
        grep -vE 'localhost|127\.0\.0\.1|example\.com|\$|\\n' | \
        grep -E '\.(com|org|net|io|cloud|dev|co)/|github\.com' | \
        sort -u | head -5)

    # JIRA tickets
    jira=$(grep -oE '\b(PSEC|O11Y|INFRA|SEC|ENG|CLOUD)-[0-9]+\b' "$filepath" 2>/dev/null | \
        sort -u | tr '\n' ' ')

    # Git branches from metadata
    branches=$(grep -oE '"gitBranch":"[^"]+' "$filepath" 2>/dev/null | \
        sed 's/"gitBranch":"//' | \
        grep -v '^$' | sort -u | tr '\n' ' ')

    # Output
    [[ -n "$jira" ]] && echo "JIRA:${jira}"
    [[ -n "$branches" ]] && echo "BRANCH:${branches}"
    [[ -n "$urls" ]] && echo "URL:${urls}"
}

# Helper: Count messages in a session file
get_message_count() {
    local filepath="$1"
    local user_count assistant_count
    user_count=$(grep -c '"type":"user"' "$filepath" 2>/dev/null || echo 0)
    assistant_count=$(grep -c '"type":"assistant"' "$filepath" 2>/dev/null || echo 0)
    echo "${user_count}/${assistant_count}"
}

# Helper: Format file size
format_size() {
    local size=$1
    if (( size >= 1048576 )); then
        awk "BEGIN {printf \"%.1fM\", $size/1048576}"
    elif (( size >= 1024 )); then
        awk "BEGIN {printf \"%.1fK\", $size/1024}"
    else
        echo "${size}B"
    fi
}

# Helper: Shorten path for display
shorten_path() {
    local path="$1"
    path="${path/#$HOME\/workspace\/github.com\//gh:}"
    path="${path/#$HOME\/workspace\//ws:}"
    path="${path/#$HOME\//~/}"
    echo "$path"
}

# Helper: Parse date string to epoch seconds (macOS compatible)
# Supports formats: YYYY, YYYY.MM, YYYY.MM.DD (and legacy formats)
# Args: input, mode ("from" or "to")
#   - "from": returns start of period (beginning of year/month/day)
#   - "to": returns end of period (end of year/month/day)
parse_date() {
    local input="$1"
    local mode="${2:-from}"  # default to "from" behavior
    local epoch year month day

    # Normalize: remove ordinal suffixes (1st, 2nd, 3rd, 4th, etc)
    input=$(echo "$input" | sed -E 's/([0-9])(st|nd|rd|th)/\1/gi')

    # YYYY format (year only)
    if [[ "$input" =~ ^[0-9]{4}$ ]]; then
        year="$input"
        if [[ "$mode" == "to" ]]; then
            # End of year: Dec 31 23:59:59
            epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$year-12-31 23:59:59" +%s 2>/dev/null)
        else
            # Start of year: Jan 1 00:00:00
            epoch=$(date -j -f "%Y-%m-%d" "$year-01-01" +%s 2>/dev/null)
        fi
        [[ -n "$epoch" ]] && echo "$epoch" && return 0
    fi

    # YYYY.MM format (year and month)
    if [[ "$input" =~ ^([0-9]{4})\.([0-9]{1,2})$ ]]; then
        year="${BASH_REMATCH[1]}"
        month="${BASH_REMATCH[2]}"
        # Pad month to 2 digits
        month=$(printf "%02d" "$month")
        if [[ "$mode" == "to" ]]; then
            # End of month: subtract 1 second from start of next month
            local next_month=$((10#$month + 1))
            local next_year="$year"
            if [[ $next_month -gt 12 ]]; then
                next_month=1
                next_year=$((year + 1))
            fi
            next_month=$(printf "%02d" "$next_month")
            local next_start
            next_start=$(date -j -f "%Y-%m-%d" "$next_year-$next_month-01" +%s 2>/dev/null)
            epoch=$((next_start - 1))
        else
            # Start of month: 1st day 00:00:00
            epoch=$(date -j -f "%Y-%m-%d" "$year-$month-01" +%s 2>/dev/null)
        fi
        [[ -n "$epoch" ]] && echo "$epoch" && return 0
    fi

    # YYYY.MM.DD format (full date with dots)
    if [[ "$input" =~ ^([0-9]{4})\.([0-9]{1,2})\.([0-9]{1,2})$ ]]; then
        year="${BASH_REMATCH[1]}"
        month=$(printf "%02d" "${BASH_REMATCH[2]}")
        day=$(printf "%02d" "${BASH_REMATCH[3]}")
        if [[ "$mode" == "to" ]]; then
            epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$year-$month-$day 23:59:59" +%s 2>/dev/null)
        else
            epoch=$(date -j -f "%Y-%m-%d" "$year-$month-$day" +%s 2>/dev/null)
        fi
        [[ -n "$epoch" ]] && echo "$epoch" && return 0
    fi

    # Legacy: ISO format 2025-11-01
    if [[ "$input" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        if [[ "$mode" == "to" ]]; then
            epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$input 23:59:59" +%s 2>/dev/null)
        else
            epoch=$(date -j -f "%Y-%m-%d" "$input" +%s 2>/dev/null)
        fi
        [[ -n "$epoch" ]] && echo "$epoch" && return 0
    fi

    # Legacy: US format 11/1/2025
    if [[ "$input" =~ ^[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}$ ]]; then
        if [[ "$mode" == "to" ]]; then
            local parsed
            parsed=$(date -j -f "%m/%d/%Y" "$input" +"%Y-%m-%d" 2>/dev/null)
            epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$parsed 23:59:59" +%s 2>/dev/null)
        else
            epoch=$(date -j -f "%m/%d/%Y" "$input" +%s 2>/dev/null)
        fi
        [[ -n "$epoch" ]] && echo "$epoch" && return 0
    fi

    # Legacy: "Month Day Year" format
    for fmt in "%B %d %Y" "%b %d %Y" "%d %B %Y" "%d %b %Y"; do
        local parsed
        parsed=$(date -j -f "$fmt" "$input" +"%Y-%m-%d" 2>/dev/null)
        if [[ -n "$parsed" ]]; then
            if [[ "$mode" == "to" ]]; then
                epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$parsed 23:59:59" +%s 2>/dev/null)
            else
                epoch=$(date -j -f "%Y-%m-%d" "$parsed" +%s 2>/dev/null)
            fi
            [[ -n "$epoch" ]] && echo "$epoch" && return 0
        fi
    done

    return 1
}

# Helper: Get file modification time as epoch seconds (macOS)
get_file_mtime_epoch() {
    stat -f %m "$1" 2>/dev/null
}

# Helper: Get session start time as epoch seconds
# Extracts first timestamp from JSONL and converts UTC to local epoch
get_session_start_epoch() {
    local filepath="$1"
    local ts_utc epoch

    ts_utc=$(grep -m1 '"timestamp"' "$filepath" 2>/dev/null | \
        grep -o '"timestamp":"[^"]*"' | head -1 | cut -d'"' -f4)

    [[ -z "$ts_utc" ]] && return 1

    # Parse UTC timestamp and convert to epoch
    epoch=$(date -j -u -f "%Y-%m-%dT%H:%M:%S" "${ts_utc%%.*}" "+%s" 2>/dev/null)
    [[ -n "$epoch" ]] && echo "$epoch" && return 0
    return 1
}

# Helper: Get session start time formatted for display (local time)
get_session_start_display() {
    local filepath="$1"
    local epoch
    epoch=$(get_session_start_epoch "$filepath")
    [[ -z "$epoch" ]] && echo "" && return
    date -r "$epoch" "+%b %d %H:%M" 2>/dev/null
}

# Helper: Check if file is within date range
# Args: filepath, from_epoch, to_epoch, filter_mode (start|last)
file_in_date_range() {
    local filepath="$1"
    local from_epoch="$2"
    local to_epoch="$3"
    local filter_mode="$4"  # "start" or "last"
    local file_epoch

    # If no date filters, always return true
    [[ -z "$from_epoch" && -z "$to_epoch" ]] && return 0

    # Get the appropriate epoch based on filter mode
    if [[ "$filter_mode" == "start" ]]; then
        file_epoch=$(get_session_start_epoch "$filepath")
        # Fall back to mtime if no start timestamp
        [[ -z "$file_epoch" ]] && file_epoch=$(get_file_mtime_epoch "$filepath")
    else
        file_epoch=$(get_file_mtime_epoch "$filepath")
    fi

    [[ -z "$file_epoch" ]] && return 1

    # Check from date
    if [[ -n "$from_epoch" && "$file_epoch" -lt "$from_epoch" ]]; then
        return 1
    fi

    # Check to date
    if [[ -n "$to_epoch" && "$file_epoch" -gt "$to_epoch" ]]; then
        return 1
    fi

    return 0
}

# Main function
main() {
    local count=$DEFAULT_COUNT
    local include_agents=false
    local short_paths=false
    local verbose=false
    local json_output=false
    local current_dir_only=false
    local search_pattern=""
    local case_insensitive=false
    local from_epoch=""
    local to_epoch=""
    local filter_mode="last"  # "start" or "last"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--all) include_agents=true; shift ;;
            -s|--short) short_paths=true; shift ;;
            -v|--verbose) verbose=true; shift ;;
            -g|--grep) search_pattern="$2"; shift 2 ;;
            -i) case_insensitive=true; shift ;;
            -j|--json) json_output=true; shift ;;
            -n) count="$2"; shift 2 ;;
            --from)
                from_epoch=$(parse_date "$2" "from")
                if [[ -z "$from_epoch" ]]; then
                    echo "Error: Could not parse date '$2'" >&2
                    echo "Formats: YYYY, YYYY.MM, YYYY.MM.DD (e.g., 2025, 2025.12, 2025.12.01)" >&2
                    return 1
                fi
                shift 2
                ;;
            --to)
                to_epoch=$(parse_date "$2" "to")
                if [[ -z "$to_epoch" ]]; then
                    echo "Error: Could not parse date '$2'" >&2
                    echo "Formats: YYYY, YYYY.MM, YYYY.MM.DD (e.g., 2025, 2025.12, 2025.12.01)" >&2
                    return 1
                fi
                shift 2
                ;;
            --by-start) filter_mode="start"; shift ;;
            --by-last) filter_mode="last"; shift ;;
            --here) current_dir_only=true; shift ;;
            -h|--help)
                cat <<'HELP'
Usage: ccss [options] [count]

Browse and search recent Claude Code sessions from ~/.claude/projects

Options:
  -n COUNT       Number of sessions to show (default: 3)
  -a, --all      Include agent/subagent sessions
  -s, --short    Use shortened paths (gh:, ws:, ~/)
  -v, --verbose  Show extra info (refs, file path, message count)
  -g, --grep     Search sessions for keyword (case-sensitive)
  -i             Case-insensitive search (use with -g)
  -j, --json     Output as JSON (one object per line)
  --from DATE    Only show sessions on or after DATE
  --to DATE      Only show sessions on or before DATE
  --by-start     Filter date range by session start time
  --by-last      Filter date range by last activity (default)
  --here         Only show sessions for current directory
  -h, --help     Show this help

Date formats:
  YYYY         Year only (e.g., 2025)
  YYYY.MM      Year and month (e.g., 2025.12)
  YYYY.MM.DD   Full date (e.g., 2025.12.01)

Examples:
  ccss           # Show 3 most recent sessions
  ccss -n 20     # Show 20 most recent sessions
  ccss -s        # Use shortened paths
  ccss -v        # Show refs, file path, message counts
  ccss -g Tutor  # Case-sensitive search
  ccss --here    # Sessions for current directory only
  ccss -j | jq   # JSON output for scripting
  ccss --from 2025.11 --to 2025.12      # Nov-Dec 2025
  ccss --from 2025.12.01 --to 2025.12.05
  ccss --from 2025 --by-start           # All of 2025 by start
HELP
                return 0
                ;;
            [0-9]*) count="$1"; shift ;;
            *)
                echo "Unknown option: $1" >&2
                echo "Use -h for help" >&2
                return 1
                ;;
        esac
    done

    [[ ! -d "$PROJECTS_DIR" ]] && {
        echo "No Claude projects directory found at $PROJECTS_DIR" >&2
        return 1
    }

    # Get list of session files sorted by modification time
    local file_list
    local search_dir="$PROJECTS_DIR"

    # If --here flag, limit to current directory's project folder
    if $current_dir_only; then
        local cwd_encoded
        cwd_encoded=$(pwd | sed 's/^\///' | sed 's/[\/.]/-/g')
        search_dir="${PROJECTS_DIR}/-${cwd_encoded}"
        [[ ! -d "$search_dir" ]] && {
            echo "No sessions found for current directory" >&2
            return 1
        }
    fi

    # Build file list (bash 3 compatible)
    local files_str all_files matched_count=0

    # Get all files sorted by time
    if $include_agents; then
        all_files=$(find "$search_dir" -name "*.jsonl" -type f -print0 2>/dev/null | \
            xargs -0 ls -t 2>/dev/null)
    else
        all_files=$(find "$search_dir" -name "*.jsonl" -type f ! -name "agent-*.jsonl" -print0 2>/dev/null | \
            xargs -0 ls -t 2>/dev/null)
    fi

    # Determine if we need to filter files
    local needs_filtering=false
    [[ -n "$search_pattern" || -n "$from_epoch" || -n "$to_epoch" ]] && needs_filtering=true

    if $needs_filtering; then
        # Set up grep options if searching
        local grep_opts="-q"
        $case_insensitive && grep_opts="-qi"

        files_str=""
        while IFS= read -r f; do
            [[ -z "$f" ]] && continue

            # Check date range first (faster than grep)
            if ! file_in_date_range "$f" "$from_epoch" "$to_epoch" "$filter_mode"; then
                continue
            fi

            # Check grep pattern if specified
            if [[ -n "$search_pattern" ]]; then
                if ! grep $grep_opts "$search_pattern" "$f" 2>/dev/null; then
                    continue
                fi
            fi

            # File passed all filters
            files_str+="$f"$'\n'
            ((matched_count++))
            [[ $matched_count -ge $count ]] && break
        done <<< "$all_files"
    else
        # No filters - just get recent files
        files_str=$(echo "$all_files" | head -n "$count")
    fi

    # Convert to array (works in bash 3 - intentionally unquoted for word splitting)
    local IFS=$'\n'
    # shellcheck disable=SC2206
    file_list=($files_str)
    unset IFS

    [[ ${#file_list[@]} -eq 0 ]] && {
        local err_msg="No sessions found"
        [[ -n "$search_pattern" ]] && err_msg+=" matching '$search_pattern'"
        [[ -n "$from_epoch" || -n "$to_epoch" ]] && err_msg+=" in specified date range"
        echo "$err_msg" >&2
        return 1
    }

    # Process each file
    local filepath size size_human time_str start_str filename summary project_path display_path last_prompt msg_count
    for filepath in "${file_list[@]}"; do
        [[ -z "$filepath" || ! -f "$filepath" ]] && continue

        # Get file stats (macOS stat syntax)
        size=$(stat -f %z "$filepath" 2>/dev/null)
        time_str=$(stat -f "%Sm" -t "%b %d %H:%M" "$filepath" 2>/dev/null)
        start_str=$(get_session_start_display "$filepath")
        filename=$(basename "$filepath" .jsonl)

        # Extract metadata from JSONL
        summary=$(head -1 "$filepath" 2>/dev/null | jq -r '.summary // empty' 2>/dev/null | \
            sed 's/<system-reminder>.*//' | tr '\n' ' ' | sed 's/  */ /g' | head -c 70)
        project_path=$(grep -m1 '"cwd"' "$filepath" 2>/dev/null | jq -r '.cwd // empty' 2>/dev/null)
        last_prompt=$(get_last_prompt "$filepath")

        # Fallback for project path
        [[ -z "$project_path" ]] && \
            project_path=$(basename "$(dirname "$filepath")" | sed 's/^-/\//' | sed 's/-/\//g')

        # Choose display path based on -s flag
        if $short_paths; then
            display_path=$(shorten_path "$project_path")
        else
            display_path="$project_path"
        fi

        size_human=$(format_size "$size")

        if $json_output; then
            # JSON output - always include all data
            local refs_raw jira_json branch_json
            refs_raw=$(get_refs "$filepath")
            jira_json=$(echo "$refs_raw" | grep '^JIRA:' | sed 's/^JIRA://' | xargs | sed 's/ /","/g')
            branch_json=$(echo "$refs_raw" | grep '^BRANCH:' | sed 's/^BRANCH://' | xargs | sed 's/ /","/g')
            [[ -n "$jira_json" ]] && jira_json="[\"$jira_json\"]" || jira_json="[]"
            [[ -n "$branch_json" ]] && branch_json="[\"$branch_json\"]" || branch_json="[]"
            msg_count=$(get_message_count "$filepath")

            # shellcheck disable=SC2001
            printf '{"file":"%s","project":"%s","session_id":"%s","size":"%s","started":"%s","modified":"%s","messages":"%s","summary":"%s","last_prompt":"%s","jira":%s,"branches":%s}\n' \
                "$filepath" "$project_path" "$filename" "$size_human" "${start_str:-$time_str}" "$time_str" "$msg_count" \
                "$(echo "$summary" | sed 's/"/\\"/g')" \
                "$(echo "$last_prompt" | sed 's/"/\\"/g')" \
                "$jira_json" "$branch_json"
        else
            # Human-readable output - show start‚Üílast if different, otherwise just one time
            if [[ -n "$start_str" && "$start_str" != "$time_str" ]]; then
                printf "${C_CYAN}%s${C_RESET}${C_GRAY}‚Üí${C_RESET}${C_CYAN}%-12s${C_RESET} ${C_YELLOW}%6s${C_RESET}  %s\n" \
                    "$start_str" "$time_str" "$size_human" "$display_path"
            else
                printf "${C_CYAN}%-12s${C_RESET} ${C_YELLOW}%6s${C_RESET}  %s\n" "$time_str" "$size_human" "$display_path"
            fi

            [[ -n "$summary" && "$summary" != " " ]] && \
                printf "                          ${C_GRAY}‚îî‚îÄ %s${C_RESET}\n" "$summary"

            [[ -n "$last_prompt" ]] && \
                printf "                          ${C_MAGENTA}‚ñ∂  %s${C_RESET}\n" "$last_prompt"

            # Verbose: show refs, message count, and file path
            if $verbose; then
                msg_count=$(get_message_count "$filepath")
                printf "                          ${C_GRAY}üìä %s messages (user/assistant)${C_RESET}\n" "$msg_count"

                local refs_output jira_refs branch_refs url_refs
                refs_output=$(get_refs "$filepath")
                if [[ -n "$refs_output" ]]; then
                    jira_refs=$(echo "$refs_output" | grep '^JIRA:' | sed 's/^JIRA://')
                    branch_refs=$(echo "$refs_output" | grep '^BRANCH:' | sed 's/^BRANCH://')
                    url_refs=$(echo "$refs_output" | grep '^URL:' | sed 's/^URL://' | head -c 100)

                    [[ -n "$jira_refs" ]] && \
                        printf "                          ${C_ORANGE}üé´ %s${C_RESET}\n" "$jira_refs"
                    [[ -n "$branch_refs" ]] && \
                        printf "                          ${C_GREEN}üåø %s${C_RESET}\n" "$branch_refs"
                    [[ -n "$url_refs" ]] && \
                        printf "                          ${C_BLUE}üîó %s${C_RESET}\n" "$url_refs"
                fi

                printf "                          ${C_GRAY}üìÅ %s${C_RESET}\n" "$filepath"
            fi

            printf "                          ${C_GRAY}   %s${C_RESET}\n" "$filename"
        fi
    done
}

# Only run main when executed directly, not when sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
